"use strict";(self.webpackChunkmidoc=self.webpackChunkmidoc||[]).push([[130],{7735(e){e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/2026/02/04/sdd-didactico","metadata":{"permalink":"/blog/2026/02/04/sdd-didactico","editUrl":"https://github.com/example/midoc/tree/main/blog/2026-02-04-sdd-didactico.md","source":"@site/blog/2026-02-04-sdd-didactico.md","title":"Specification Driven-Development: What SDD is and understanding its role","description":"A friendly introduction to Specification Driven Development (SDD) and its role in AI-assisted development.","date":"2026-02-04T00:00:00.000Z","tags":[{"inline":true,"label":"sdd","permalink":"/blog/tags/sdd"},{"inline":true,"label":"specification","permalink":"/blog/tags/specification"},{"inline":true,"label":"development","permalink":"/blog/tags/development"},{"inline":true,"label":"ai","permalink":"/blog/tags/ai"},{"inline":true,"label":"didactic","permalink":"/blog/tags/didactic"}],"readingTime":2.77,"hasTruncateMarker":false,"authors":[{"name":"Emi","url":"https://emi-dm.github.io","socials":{},"key":null,"page":null}],"frontMatter":{"title":"Specification Driven-Development: What SDD is and understanding its role","authors":[{"name":"Emi","url":"https://emi-dm.github.io"}],"date":"2026-02-04T00:00:00.000Z","tags":["sdd","specification","development","ai","didactic"],"description":"A friendly introduction to Specification Driven Development (SDD) and its role in AI-assisted development."},"unlisted":false,"nextItem":{"title":"Skills: Using `find-skills` from VS Code","permalink":"/blog/2026/02/04/skills-find-skills"}},"content":"**TL;DR:** SDD puts the specification at the center: well-written specifications can be used to generate code via AI agents. Fewer misunderstandings, faster iteration.\\n\\n## Definition of the concept\\n\\nImagine the specification is the recipe and the code is the final dish. In **Specification Driven Development (SDD)**, the recipe is not a poor note in the margin; it\'s the manual that the chefs (including robot chefs\u2014LLMs) use to cook the application.\\n\\nSDD emerges as a philosophy in response to LLM-based agents and _vibe coding_: instead of writing code first and then documentation, well-written and executable documentation becomes the \\"source of truth\\" and guides code generation.\\n\\n> Quick example: you write a specification: \\"When button X is pressed, send notification Y to the user with conditions Z\\". An agent can transform that specification into endpoints, tests, and minimum viable deployment. Simple, repeatable, and traceable.\\n\\n## Source of truth\\n\\n- **Agile / Waterfall**: Code rules. Specs often become outdated notes.\\n- **SDD**: The specification rules. Code is a temporal expression of that specification: if something is off, the spec is the source to correct.\\n\\nIn SDD, the specification functions as a contract: when the spec and code differ, the spec is the truth until we decide otherwise (and document it).\\n\\n## Change management (by analogy)\\n\\nThink of changes as updating a recipe, not re-making the dish by hand every time:\\n\\n- **Before**: a change in requirements causes chaos: code editing, PRs, hotfixes.\\n- **With SDD**: change the spec, regenerate implementations and tests. Experiment _what-if_ at low cost.\\n\\n---\\n\\n|                            | Traditional Methodologies (Agile / Waterfall)                   | Spec-Driven Development (SDD)                                            |\\n| -------------------------- | --------------------------------------------------------------- | ------------------------------------------------------------------------ |\\n| **The Source of Truth**    | **Code is King.** Specs fall behind.                            | **The Specification is King.** The PRD generates the implementation.     |\\n| **Spec-Code Relationship** | The specification is usually static and deviates from the code. | The specification is an **executable** artifact; code is its expression. |\\n| **The Gap**                | Ambiguities and misunderstandings are inevitable.               | Automatic transformation reduces or eliminates the interpretation gap.   |\\n\\n## Why now? (trends pushing SDD)\\n\\n1. More capable AI: natural language specs generate functional code reliably.\\n2. More complex software: maintaining consistency manually is increasingly expensive.\\n3. Accelerated pace of change: pivots are the norm and you need to iterate quickly and safely.\\n\\nThis also enables an interesting game: generate multiple implementations from the same spec and compare advantages (performance vs. cost vs. maintainability).\\n\\n## Fundamental principles (one sentence each)\\n\\n1. **Specifications as lingua franca** \u2014 the spec is the central artifact.\\n2. **Executable specifications** \u2014 precise, complete, and unambiguous.\\n3. **Continuous refinement** \u2014 validation and ambiguity detection all the time.\\n4. **Research-driven context** \u2014 agents collect context and technical options.\\n5. **Bidirectional feedback** \u2014 production feeds back into the specification.\\n6. **Branching for exploration** \u2014 generate alternatives to optimize different objectives.\\n\\n## Small exercise (try it!)\\n\\nTake a user story and turn it into a minimal spec (3\u20135 lines) that\'s clear and unambiguous. Then ask yourself:\\n\\n- Can an agent generate endpoints and tests from this?\\n- What ambiguities remain?\\n\\nIf you answered yes and there\'s little ambiguity, you\'ve taken a big step toward SDD.\\n\\n## Final reflection\\n\\nSDD doesn\'t come to replace the developer: it comes to turn them into a specification architect, orchestra conductor, and curious critic. It\'s a powerful way to accelerate iterations, improve traceability, and minimize technical debt when properly implemented.\\n\\n---\\n\\n## Sources and references\\n\\n- SDD definition provided by GitHub Spec Kit: https://github.com/github/spec-kit/blob/main/spec-driven.md"},{"id":"/2026/02/04/skills-find-skills","metadata":{"permalink":"/blog/2026/02/04/skills-find-skills","editUrl":"https://github.com/example/midoc/tree/main/blog/2026-02-04-skills-find-skills.md","source":"@site/blog/2026-02-04-skills-find-skills.md","title":"Skills: Using `find-skills` from VS Code","description":"How to use the \'npx skills\' CLI and discover/install skills from VS Code","date":"2026-02-04T00:00:00.000Z","tags":[{"inline":true,"label":"skills","permalink":"/blog/tags/skills"},{"inline":true,"label":"find-skills","permalink":"/blog/tags/find-skills"},{"inline":true,"label":"vscode","permalink":"/blog/tags/vscode"}],"readingTime":1.26,"hasTruncateMarker":false,"authors":[{"name":"Emi","url":"https://emi-dm.github.io","socials":{},"key":null,"page":null}],"frontMatter":{"title":"Skills: Using `find-skills` from VS Code","authors":[{"name":"Emi","url":"https://emi-dm.github.io"}],"date":"2026-02-04T00:00:00.000Z","tags":["skills","find-skills","vscode"],"description":"How to use the \'npx skills\' CLI and discover/install skills from VS Code"},"unlisted":false,"prevItem":{"title":"Specification Driven-Development: What SDD is and understanding its role","permalink":"/blog/2026/02/04/sdd-didactico"}},"content":"This post explains how to use the `npx skills` command (the skills manager) and how to integrate it into your workflow in Visual Studio Code.\\n\\n## What is `npx skills`?\\n\\n`npx skills` is the CLI for the skills ecosystem: it helps you search, install, and update packages called *skills* that extend the agent\'s capabilities.\\n\\nKey commands:\\n\\n- Search: `npx skills find [query]`\\n- Install: `npx skills add <owner/repo@skill>`\\n- Update: `npx skills update`\\n\\n## Quick usage from VS Code\\n\\n1. Open the integrated terminal (View \u2192 Terminal or `Ctrl+\\\\``).\\n2. Search for relevant skills:\\n\\n```bash\\n# search for skills by keywords\\nnpx skills find react performance\\n```\\n\\n3. Review the output and, if interested, install one:\\n\\n```bash\\n# install a skill (global installation is optional, you can use npx directly)\\nnpx skills add vercel-labs/agent-skills@vercel-react-best-practices\\n```\\n\\n4. Optional: install globally and avoid typing `npx`:\\n\\n```bash\\nnpm i -g @skills/cli\\nskills find \\"react testing\\"\\n```\\n\\n### Practical tip\\nIf you want to work with skills frequently from VS Code, keep the terminal pinned and use searches with specific words (e.g., `react testing`, `docs`, `deploy`).\\n\\n## Example flow\\n\\n- Search: `npx skills find changelog`\\n- Install: `npx skills add composio/changelog-skill`\\n- Execute the task the skill provides: depends on the installed skill (check the documentation at skills.sh).\\n\\n## Resources\\n\\n- Website: https://skills.sh/ \ud83d\udd17\\n- Documentation and examples (use `npx skills find` to discover specific skills)\\n\\n---\\n\\nIf you want, I can install a sample skill here and show step-by-step how to use it. Which category interests you (tests, docs, deploy, productivity)?"}]}}')}}]);